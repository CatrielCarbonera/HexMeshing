
//
//   Copyright 2005-2006  @  C. Carbonera All rights reserved
//   11300 Rupp Drive
//   Burnsville, MN 55337
//   catriel.carbonera@comcast.net
//   This file can be freely redistributed for research and academic purposes only
//   under the condition that the copyright notices, including this header, "
//   are not removed.
//   This file was generated using new techniques in mesh Generation. "
//   described in 
//   \"A Constructive Approach to Hexahedral Mesh Generation\" 
//           by C.D. Carboneara.
//
//
//
//	The keywords *NODE, *ELEMENT_SHELL, and *ELEMENT_SOLID follow the 
//		LS-Dyna specification The keyword *PAIRED_PARTITION has been added to
//		indicate the paired-partition of a file definining the Constraining 
//		Quadrilateral Mesh; the paired quadrilateral elements are specified 
//		at the end of the file before the keyword *END.
//		The Paired partition follows the syntax
//			<pair number>   <quad>   <quadrilateral that shares an edge>
//		The union of all the pairs listed under this section must be equal
//		to the total set of quadrilaterals, any two pairs must be mutually
//		disjoint, and the quadrilaterals listed must share an edge.                                                       
//
#include "stdafx.h"
#include <iostream>
#include <fstream>
#include <strstream>
#include <string>
using namespace std;

#include "inc/MeshIo.h"
#include "inc/PairedElement.h"
#include "inc/Hexa.h"
#include "inc/Quad.h"
#include "inc/pt3D.h"

namespace
{
	const size_t LineLength=256;
	std::string NODE("*NODE");
	std::string ELEMENT_SHELL("*ELEMENT_SHELL");
	std::string PAIRED_PARTITION("*PAIRED_PARTITION");
	std::string END("*END");

	bool ValidKeyWord(char* wrd)
	{
		std::string word(wrd);
		return word == NODE ||
			word == ELEMENT_SHELL ||
			word == PAIRED_PARTITION  ||
			word == END ? true : false;
	}

	void ReadNodes(istream& stream, std::vector<pt3D> & pta, char word[])
	{
		char line[LineLength];
		pt3D pt;
		do 
		{
			stream.getline(line, LineLength);
			strstream lineStream(line, LineLength);
			lineStream >> word;
			if (!ValidKeyWord(word))
			{
				lineStream >> pt.x ;
				lineStream >> pt.y ;
				lineStream >> pt.z;
				pta.push_back(pt);
			}
		}while (! (!stream) && !ValidKeyWord(word) );
	}

	void ReadQuads(	istream& stream, 
					std::vector< std::pair<Quad, Quad> >& pairedPartition,
					char word[])
	{
		char line[LineLength];
		std::vector< Quad > quads;
		pt3D pt;
		Quad q;
		do
		{
			stream.getline(line, LineLength);
			if (!stream)
				return;
			strstream lineStream(line, LineLength);
			lineStream >> word;
			if (!ValidKeyWord(word))
			{
				lineStream >> word;
				lineStream >> q.idx[0];
				q.idx[0]--;
				lineStream >> q.idx[1];
				q.idx[1]--;
				lineStream >> q.idx[2];
				q.idx[2]--;
				lineStream >> q.idx[3];
				q.idx[3]--;
				quads.push_back(q);
			}
		} while ( !ValidKeyWord(word) );

		do
		{
			stream.getline(line, LineLength);
			if (!stream)
				return;
			strstream lineStream(line, LineLength);
			lineStream >> word;
			if (!ValidKeyWord(word))
			{
				int q0, q1;
				lineStream >> q0 ;
				lineStream >> q1 ;
				q0-- ;
				q1-- ;
				pairedPartition.push_back(
					std::pair<Quad,Quad>(quads[q0], quads[q1]) );
			}
		} while ( !ValidKeyWord(word) );

	}
};

void WriteNegativeHexa(const char* fileName,
				std::vector<pt3D>& pta, 
				std::vector<Hexa>& hexa
				  )
{
	std::vector<Hexa> negHex;
	for ( size_t i = 0; i < hexa.size(); ++i )
	{
		if ( hexa[i].MinDet(pta) < 0.0 )
			negHex.push_back(hexa[i]);
	}

	WriteFile(fileName,	pta, negHex);
}

void WriteFile(const char* fileName,
				std::vector<pt3D>& pta, 
				std::vector<Hexa>& hexa)
{
	ofstream dynaOut(fileName);

	dynaOut << "$$	 " << endl;
	dynaOut << "$$   Copyright 2005  (C)  C. Carbonera All rights reserved " << endl;
	dynaOut << "$$   2337 Edgcumbe Rd, St Paul, MN 55116 " << endl;
	dynaOut << "$$   e-mail: catriel.carbonera@comcast.net " << endl;
	dynaOut << "$$   This file can be freely redistributed under the condition that the copyright notices," << endl;
	dynaOut << "$$   including this header, are not removed." << endl;
	dynaOut << "$$   This file was generated using new techniques in mesh generation" << endl;
	dynaOut << "$$   described in " << endl;
	dynaOut << "$$   \"A Constructive Approach to Constrained Hexahedral Mesh Generation\" by C. Carbonera" << endl;
	dynaOut << "$$   Ls-dyna Input Deck Generated by ConstrainedHexahedralMesh.exe"<< endl;
	dynaOut << "$$	 " << endl;

	dynaOut << "*KEYWORD\n";
	dynaOut << "*NODE\n";
	for (size_t ind = 0 ; ind < pta.size(); ++ind)
	{
		dynaOut.width(8);
		dynaOut << ind+1;
		dynaOut.width(16);
		dynaOut << pta[ind].x ;
		dynaOut.width(16);
		dynaOut << pta[ind].y ;
		dynaOut.width(16);
		dynaOut << pta[ind].z << endl;
	}
	dynaOut << "*ELEMENT_SOLID\n";

	for (size_t ielem = 0; ielem < hexa.size(); ++ielem)
	{

		dynaOut.width(8);
		dynaOut << ielem+1;
		dynaOut.width(8);
		dynaOut <<hexa[ielem].group;
		for ( size_t ind = 0 ; ind < 8; ++ind )
		{
			dynaOut.width(8);
			dynaOut << hexa[ielem].idx[ind]+1;
		}
		dynaOut << endl;
	}

	dynaOut << "*END\n";
}

void WriteFile(const char* fileName,
				std::vector<pt3D>& pta, 
				std::vector<Quad>& quad)
{
	ofstream dynaOut(fileName);

	dynaOut << "$$	 " << endl;
	dynaOut << "$$   Copyright 2005  (C)  C. Carbonera All rights reserved " << endl;
	dynaOut << "$$   2337 Edgcumbe Rd, St Paul, MN 55116 " << endl;
	dynaOut << "$$   e-mail: catriel.carbonera@comcast.net " << endl;
	dynaOut << "$$   This file can be freely redistributed unter the condition that the copyright notices," << endl;
	dynaOut << "$$   including this header, are not removed." << endl;
	dynaOut << "$$   This file was generated using new techniques in mesh generation" << endl;
	dynaOut << "$$   described in \"Constrained Hexahedral Mesh Generation\" by C. Carbonera and R. Taghavi." << endl;
	dynaOut << "$$	 " << endl;

	dynaOut << "*KEYWORD\n";
	dynaOut << "*NODE\n";
	for (size_t ind = 0 ; ind < pta.size(); ++ind)
	{
		dynaOut.width(8);
		dynaOut << ind+1;
		dynaOut.width(16);
		dynaOut << pta[ind].x ;
		dynaOut.width(16);
		dynaOut << pta[ind].y ;
		dynaOut.width(16);
		dynaOut << pta[ind].z << endl;
	}
	dynaOut << "*ELEMENT_SHELL\n";
	for (size_t ielem = 0; ielem < quad.size(); ++ielem)
	{

		dynaOut.width(8);
		dynaOut << ielem+1;
		dynaOut.width(8);
		dynaOut << quad[ielem].referenceQuad; //"       1";
		for ( size_t ind = 0 ; ind < 4; ++ind )
		{
			dynaOut.width(8);
			dynaOut << quad[ielem].idx[ind]+1;
		}
		dynaOut << endl;
	}

	dynaOut << "*END\n";
}

void ReadFile(const char* fileName,
				std::vector<pt3D>& pta, 
				std::vector<Hexa>& hexa,
				std::vector< std::pair<Quad, Quad> >& pairedPartition)
{

	char line[LineLength];
	char word[32];
	ifstream dynaIn(fileName);

	while ( ! (!dynaIn) )
	{
		dynaIn.getline(line, LineLength);
		strstream lineStream(line, LineLength);
		lineStream >> word;
		std::string wordString(word);
		if (wordString == NODE)
			ReadNodes(dynaIn, pta, word);
		std::string wordString2(word);
		if (wordString2 == ELEMENT_SHELL)
			ReadQuads(dynaIn, pairedPartition, word);
	}

	for ( size_t i = 0; i < pta.size(); ++i )
	{
		pta[i].SetBoundary();
	}
}
